{
	"named": {
		"prefix": "temp",
		"body": [
			"using namespace std;",
			"#include <bits/stdc++.h>",
			"#define ll long long",
			"#define ld long double",
			"#define EL '\\n'",
			"#define el '\\n'",
			"#define all(x) x.begin(),x.end()",
			"#define rep(i, a, b) for (ll i = (a); i < (b); i++)",
			"#define repd(i, a, b) for (ll i = (b)-1; i >= (a); i--)",
			"#define large 1000000007",
			"#define MOD 1000000007",
			"#define pb push_back",
			"#define MAX 10e+7",
			"#define FASTIO ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);",
			"void solve()",
			"{",
			"$1",
			"",
			"}",
			"int main()",
			"{",
			"     #ifndef ONLINE_JUDGE",
			"    freopen(\"input.txt\", \"r\", stdin);",
			"    freopen(\"output.txt\", \"w\", stdout);",
			"#endif",
			"FASTIO",
			" long long int t;",
			" cin>>t;",
			" while(t--)",
			" {",
			"  solve();",
			"  ",
			" }",
			"  return 0;",
			"}",
			""
		],
		"description": "named"
	},
	"rohit": {
		"prefix": "solutionsininiterval",
		"body": [
			"int gcd(int a, int b, int& x, int& y) {",
			"    if (b == 0) {",
			"        x = 1;",
			"        y = 0;",
			"        return a;",
			"    }",
			"    int x1, y1;",
			"    int d = gcd(b, a % b, x1, y1);",
			"    x = y1;",
			"    y = x1 - y1 * (a / b);",
			"    return d;",
			"}",
			"",
			"bool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {",
			"    g = gcd(abs(a), abs(b), x0, y0);",
			"    if (c % g) {",
			"        return false;",
			"    }",
			"",
			"    x0 *= c / g;",
			"    y0 *= c / g;",
			"    if (a < 0) x0 = -x0;",
			"    if (b < 0) y0 = -y0;",
			"    return true;",
			"}",
			"void shift_solution(int & x, int & y, int a, int b, int cnt) {",
			"    x += cnt * b;",
			"    y -= cnt * a;",
			"}",
			"",
			"int find_all_solutions(int a, int b, int c, int minx, int maxx, int miny, int maxy) {",
			"    int x, y, g;",
			"    if (!find_any_solution(a, b, c, x, y, g))",
			"        return 0;",
			"    a /= g;",
			"    b /= g;",
			"",
			"    int sign_a = a > 0 ? +1 : -1;",
			"    int sign_b = b > 0 ? +1 : -1;",
			"",
			"    shift_solution(x, y, a, b, (minx - x) / b);",
			"    if (x < minx)",
			"        shift_solution(x, y, a, b, sign_b);",
			"    if (x > maxx)",
			"        return 0;",
			"    int lx1 = x;",
			"",
			"    shift_solution(x, y, a, b, (maxx - x) / b);",
			"    if (x > maxx)",
			"        shift_solution(x, y, a, b, -sign_b);",
			"    int rx1 = x;",
			"",
			"    shift_solution(x, y, a, b, -(miny - y) / a);",
			"    if (y < miny)",
			"        shift_solution(x, y, a, b, -sign_a);",
			"    if (y > maxy)",
			"        return 0;",
			"    int lx2 = x;",
			"",
			"    shift_solution(x, y, a, b, -(maxy - y) / a);",
			"    if (y > maxy)",
			"        shift_solution(x, y, a, b, sign_a);",
			"    int rx2 = x;",
			"",
			"    if (lx2 > rx2)",
			"        swap(lx2, rx2);",
			"    int lx = max(lx1, lx2);",
			"    int rx = min(rx1, rx2);",
			"",
			"    if (lx > rx)",
			"        return 0;",
			"    return (rx - lx) / abs(b) + 1;",
			"}",
			""
		],
		"description": "all solution usinig euclid"
	},
	"primes": {
		"prefix": "seive",
		"body": [
			"vector<char> is_prime(10001, true);",
			"void seive(int n)",
			"{",
			"//vector<char> is_prime(n+1, true);",
			"is_prime[0] = is_prime[1] = false;",
			"for (int i = 2; i <= n; i++) {",
			"    if (is_prime[i] && (long long)i * i <= n) {",
			"        for (int j = i * i; j <= n; j += i)",
			"            is_prime[j] = false;",
			"    }",
			"}",
			"}"
		],
		"description": "seive"
	},
	"ncr": {
		"prefix": "ncr%p",
		"body": [
			"#define MOD 1000000007",
			"const int N = 1000005;",
			"ll factorialNumInverse[N + 1]; ",
			"ll naturalNumInverse[N + 1]; ",
			"ll fact[N + 1]; ",
			"void InverseofNumber(ll p) ",
			"{ ",
			"    naturalNumInverse[0] = naturalNumInverse[1] = 1; ",
			"    for (int i = 2; i <= N; i++) ",
			"        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - p / i) % p; ",
			"} ",
			"void InverseofFactorial(ll p) ",
			"{ ",
			"     factorialNumInverse[0] = factorialNumInverse[1] = 1; ",
			"    for (int i = 2; i <= N; i++) ",
			"        factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p; ",
			"} ",
			"void factorial(ll p) ",
			"{ ",
			"    fact[0] = 1;  ",
			"    for (int i = 1; i <= N; i++) { ",
			"        fact[i] = (fact[i - 1] * i) % p; ",
			"    } ",
			"} ",
			"ll Binomial(ll N, ll R, ll p=MOD) ",
			"{ ",
			"  if(N<0||R<0||R>N) return 0;             ", 
			"    ll ans = ((fact[N] * factorialNumInverse[R]) ",
			"              % p * factorialNumInverse[N - R]) ",
			"             % p; ",
			"    return ans%p; ",
			"}   ",
			"ll power(ll x, ll y, ll p) ",
			"{ ",
			"    int res = 1;",
			"    x = x % p;",
			"    while (y > 0) ",
			"    {  ",
			"        if (y & 1) ",
			"            res = (res*x) % p;  ",
			"        y = y>>1; // y = y/2 ",
			"        x = (x*x) % p; ",
			"    } ",
			"    return res; ",
			"} "
		],
		"description": "ncr%p"
	},
	"fenwicktree": {
		"prefix": "fenwicktree",
		"body": [
			"class BIT",
			"{",
			"int *ft, size;",
			"",
			"public:",
			"BIT(int n)",
			"{",
			"size = n;",
			"ft = new int[n + 1];",
			"fill_n(ft,n+1,0);",
			"}",
			"~BIT()",
			"{",
			"delete[] ft;",
			"}",
			"int sum(int b)",
			"{",
			"int sum = 0;",
			"for (; b; b -= b & (-b))",
			"sum += ft[b];",
			"return sum;",
			"}",
			"void update(int k, int v)",
			"{",
			"for (; k <= size; k += k & (-k))",
			"ft[k] += v;",
			"}",
			"int sumr(int a, int b)",
			"{",
			"return sum(b) - (a == 1 ? 0 : sum(a - 1));",
			"}",
			"int getValue(int x)",
			"{",
			"return sum(x) - sum(x - 1);",
			"}",
			"void changeElem(int x, int val)",
			"{",
			"update(x , val - getValue(x));",
			"}",
			"void scaleDown(int c)",
			"{",
			"for (int i = 1; i <= size; i++)",
			"ft[i] /= c;",
			"}",
			"void scaleUp(int c)",
			"{",
			"for (int i = 1; i <= size; i++)",
			"ft[i] *= c;",
			"}",
			"};",
			""
		],
		"description": "fenwick tree"
	},
	"temp1": {
		"prefix": "emp1",
		"body": [
			"using namespace std;",
			"#include <bits/stdc++.h>",
			"#define FASTIO ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);",
			"#define ll long long",
			"#define debug(x) cout << #x <<\" = \" << x << endl",
			"void solve()",
			"{",
			"$1",
			"",
			"}",
			"int main()",
			"{",
			"     #ifndef ONLINE_JUDGE",
			"    freopen(\"input.txt\", \"r\", stdin);",
			"    freopen(\"output.txt\", \"w\", stdout);",
			"#endif",
			"FASTIO",
			" long long int t=1;",
			" cin>>t;",
			" while(t--)",
			"  solve();",
			"  return 0;",
			"}",
			""
		],
		"description": "named"
	},
	"solutionofequation": {
		"prefix": "solutionofequation",
		"body": [
			"int gcd(int a, int b, int& x, int& y) {",
			"    if (b == 0) {",
			"        x = 1;",
			"        y = 0;",
			"        return a;",
			"    }",
			"    int x1, y1;",
			"    int d = gcd(b, a % b, x1, y1);",
			"    x = y1;",
			"    y = x1 - y1 * (a / b);",
			"    return d;",
			"}",
			"",
			"bool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {",
			"    g = gcd(abs(a), abs(b), x0, y0);",
			"    if (c % g) {",
			"        return false;",
			"    }",
			"",
			"    x0 *= c / g;",
			"    y0 *= c / g;",
			"    if (a < 0) x0 = -x0;",
			"    if (b < 0) y0 = -y0;",
			"    return true;",
			"}"
		],
		"description": "2 variable solution"
	},
	"power": {
		"prefix": "exponent",
		"body": [
			"#define MOD 1000000007",
			"ll power(ll x, ll y, ll p) ",
			"{ ",
			"    int res = 1;",
			"    x = x % p;",
			"    while (y > 0) ",
			"    {  ",
			"        if (y & 1) ",
			"            res = (res*x) % p;  ",
			"        y = y>>1; // y = y/2 ",
			"        x = (x*x) % p; ",
			"    } ",
			"    return res; ",
			"} "
		],
		"description": "a power b"
	},
	"long": {
		"prefix": "lamba",
		"body": [
			"#define ll long long"
		],
		"description": "long long"
	},
	"segment tree": {
		"prefix": "segmenttree",
		"body": [
			"struct item",
			"{",
			"    int a, c;",
			"};",
			"struct segmenttree",
			"{",
			"    int size;",
			"    int ele;",
			"    item single(int v)",
			"    {",
			"        return {v,1};",
			"    }",
			"    item NEUTRAL_ELEMENT={INT_MAX,0};",
			"    vector<item> values;",
			"    void init(int n)",
			"    {",
			"        ele = n;",
			"        size = 4 * n + 1;",
			"        values.resize(size);",
			"    }",
			"    item merge(item x,item y)",
			"    {",
			"       if(x.a<y.a) return x;",
			"       else if(x.a>y.a) return y;",
			"       else return {x.a,x.c+y.c};",
			"    }",
			"    void build(int *arr)",
			"    {",
			"        build(arr,1,0,ele-1);",
			"    }",
			"    void build(int *arr, int index, int s, int e)",
			"    {",
			"        if (s > e)",
			"            return;",
			"        if (s == e)",
			"        {",
			"            values[index]=single(arr[s]);",
			"            return;",
			"        }",
			"        int mid = (s + e) / 2;",
			"        build( arr, 2 * index, s, mid);",
			"        build( arr, 2 * index + 1, mid + 1, e);",
			"        values[index] = merge(values[2*index],values[2*index+1]);",
			"    }",
			"    void update(int i, int val)",
			"    {",
			"        update(0, ele - 1, 1, val, i);",
			"    }",
			"    void update(int s, int e, int index, int val, int i)",
			"    {",
			"        if (i < s || i > e)",
			"            return;",
			"        else if (s == e)",
			"        {",
			"            values[index] = single(val);",
			"            return;",
			"        }",
			"        int mid = (s + e) / 2;",
			"        update(s, mid, 2 * index, val, i);",
			"        update(mid + 1, e, 2 * index + 1, val, i);",
			"        values[index] = merge(values[2 * index] , values[2 * index + 1]);",
			"    }",
			"    item query(int qs, int qe)",
			"    {",
			"        return query(0, ele - 1, qs, qe, 1);",
			"    }",
			"    item query(int s, int e, int qs, int qe, int index)",
			"    {",
			"        if (qs > e || qe < s)",
			"            return NEUTRAL_ELEMENT;",
			"        if (s >= qs && e <= qe)",
			"            return values[index];",
			"        int mid = (s + e) / 2;",
			"        item lans = query(s, mid, qs, qe, 2 * index);",
			"        item rans = query(mid + 1, e, qs, qe, 2 * index + 1);",
			"        return  merge(lans, rans);",
			"    }",
			"};"
		],
		"description": "segment tree in genral form"
	},
	"equal ot greater index": {
		"prefix": "greaterthanindex",
		"body": [
			"int bsh(int val, int ar[], int n) {",
			"//return ind such that val >= ar[ind] and val < ar[ind+1] ",
			"int a = 0, b = n - 1, c = (a+b)/2;",
			"if (val < ar[0]) return -1;",
			"if (val >= ar[b]) return b;",
			" ",
			"while (!(val >= ar[c] && val < ar[c+1])) {",
			"if (val < ar[c]) b = c;",
			"else {",
			"if (b-a == 1 && c == a) a = b;",
			"else a = c;",
			"}",
			"c = (a+b)/2;",
			"}",
			"return c;",
			"}"
		],
		"description": "not in this one"
	},
	"largest power of 2 less than or equal to given number": {
		"prefix": "poweroftwolessthanorequal",
		"body": [
			"long long largest_power_of_two_less_than_or_equal(long long N)",
			"{",
			"    N = N | (N >> 1);",
			"    N = N | (N >> 2);",
			"    N = N | (N >> 4);",
			"    N = N | (N >> 8);",
			"    N = N | (N >> 16);",
			"    N = N | (N >> 32);",
			"    return (N + 1) >> 1;",
			"}"
		],
		"description": "."
	},
	"input output in side": {
		"prefix": "inputoutput",
		"body": [
			"  #ifndef ONLINE_JUDGE",
			"    freopen(\"input.txt\", \"r\", stdin);",
			"    freopen(\"output.txt\", \"w\", stdout);",
			"#endif"
		],
		"description": "for fast check"
	},
	"debugerichto": {
		"prefix": "debugerichto",
		"body": [
			"#define sim template < class c",
			"#define ris return * this",
			"#define dor > debug & operator <<",
			"#define eni(x) sim > typename \\",
			"enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {",
			"sim > struct rge { c b, e; };",
			"sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }",
			"sim > auto dud(c* x) -> decltype(cerr << *x, 0);",
			"sim > char dud(...);",
			"struct debug {",
			"~debug() { cerr << endl; }",
			"eni(!=) cerr << boolalpha << i; ris; }",
			"eni(==) ris << range(begin(i), end(i)); }",
			"sim, class b dor(pair < b, c > d) {",
			"  ris << \"(\" << d.first << \", \" << d.second << \")\";",
			"}",
			"sim dor(rge<c> d) {",
			"  *this << \"[\";",
			"  for (auto it = d.b; it != d.e; ++it)",
			"*this << \", \" + 2 * (it == d.b) << *it;",
			"  ris << \"]\";",
			"}",
			"};",
			"#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \""
		],
		"description": "warsaw template "
	},
	"lca of given nodes": {
		"prefix": "lca",
		"body": [
			"vector<int> adj[100001];",
			"bool visited[100001];",
			"int dis[100001];",
			"int par[100001];",
			"int table[100001][100];",
			"int maxn=log2(100001);",
			"int n,q;",
			"void dfs(int v,int p=-1)",
			"{",
			"  visited[v]=1;",
			"  if(p==-1)",
			"  dis[v]=0;",
			"  else",
			"  dis[v]=dis[p]+1;",
			"  par[v]=p;",
			"  table[v][0]=p;",
			"  for(auto it:adj[v])",
			"  {",
			"    if(!visited[it])",
			"    dfs(it,v);",
			"  }",
			"}",
			"void init()",
			"{",
			"  dfs(1);",
			"  for (int i = 1; i <=maxn; i++)",
			"  {",
			"    for (int j = 1; j <=n; j++)",
			"    {",
			"      if(table[j][i-1]!=-1)",
			"      {",
			"        int par=table[j][i-1];",
			"        table[j][i]=table[par][i-1];",
			"      }",
			"    }",
			"  }",
			"}",
			"int lca_fast(int a,int b)",
			"{",
			"  if(dis[b]<dis[a])",
			"  swap(a,b);",
			"  int d=dis[b]-dis[a];",
			"  while(d>0)",
			"  {",
			"    int base=log2(d);",
			"    b=table[b][base];",
			"    d-=(1<<base);",
			"  }",
			"  if(a==b)",
			"  return a;",
			"  for(int i=maxn;i>=0;i--)",
			"  {",
			"     if(table[a][i]!=-1&&table[b][i]!=-1&&table[a][i]!=table[b][i])",
			"     a=table[a][i],b=table[b][i];",
			"  }",
			"  return par[a];",
			"}",
		    "int goup(int b,int d)",
            "{",
            "while(d>0)",
             "{",
            "int base=log2(d);",
             "b=table[b][base];",
             "if(b==-1)",
            "return -1;",
            "d-=(1<<base);",
			"}",
            "return b;",
			"}",
		],
		"description": "finds lca in log(n) time"
	}
	,
	"khan algo": {
		"prefix": "topsortkhan",
		"body": [
		  "vector<int> top_order; ",
		  "bool topologicalsort() ",
		  "{ ",
		  "vector<int> in_degree(n+1, 0); ",
		  "for (int u = 1; u <=n; u++) { ",
		  "for (auto itr = adj[u].begin(); ",
		  "itr != adj[u].end(); itr++) ",
		  "in_degree[*itr]++; ",
		  "} ",
		  "queue<int> q; ",
		  "for (int i = 1; i <=n; i++) ",
		  "if (in_degree[i] == 0) ",
		  "q.push(i); ",
		  "int cnt = 0; ",
		  "while (!q.empty()) { ",
		  "int u = q.front(); ",
		  "q.pop(); ",
		  "top_order.push_back(u); ",
		  "for (auto itr = adj[u].begin(); ",
		  "itr != adj[u].end(); itr++) ",
		  "if (--in_degree[*itr] == 0) ",
		  "q.push(*itr); ",
		  "",
		  "cnt++; ",
		  "}",
		  "  if(cnt!=n)",
		  "  return false;",
		  "  return true;",
		  "} "
		],
		"description": "for khan algo for top sort"
	  }
	  ,
	  "articulation points": {
		"prefix": "articulationpoints",
		"body": [
		  "void dfs(int v, int p = -1) {",
		  "    visited[v] = true;",
		  "    in[v] = low[v] = timer++;",
		  "    int children=0;",
		  "    for (int to : adj[v]) {",
		  "        if (to == p) continue;",
		  "        if (visited[to]) {",
		  "            low[v] = min(low[v], in[to]);",
		  "        } else {",
		  "            dfs(to, v);",
		  "            low[v] = min(low[v], low[to]);",
		  "            if (low[to] >= in[v] && p!=-1)",
		  "                IS_CUTPOINT(v);",
		  "            ++children;",
		  "        }",
		  "    }",
		  "    if(p == -1 && children > 1)",
		  "",
		  "        IS_CUTPOINT(v);",
		  "}"
		],
		"description": "cut points"
	  }
	  ,
	  "bridges": {
		"prefix": "bridges",
		"body": [
		  "void dfs(int v, int p = -1) {",
		  "    visited[v] = true;",
		  "    in[v] = low[v] = timer++;",
		  "    for (int to : adj[v]) {",
		  "        if (to == p) continue;",
		  "        if (visited[to]) {",
		  "            low[v] = min(low[v], in[to]);",
		  "        } else {",
		  "            dfs(to, v);",
		  "            low[v] = min(low[v], low[to]);",
		  "            if (low[to] > in[v])",
		  "                IS_BRIDGE(v, to);",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "find all bridges"
	  }
	  ,
	  "top sort cp algo approach": {
		"prefix": "topsortall",
		"body": [
		  "vector<bool> visited(100011);",
		  "void dfs(int v) {",
		  "    visited[v] = true;",
		  "    for (int u : adj[v]) {",
		  "        if (!visited[u])",
		  "            dfs(u);",
		  "    }",
		  "    top_order.push_back(v);",
		  "}",
		  "void topological_sort() {",
		  "    visited.assign(n+1, false);",
		  "    top_order.clear();",
		  "    for (int i = 1; i <=n; ++i) {",
		  "        if (!visited[i])",
		  "            dfs(i);",
		  "    }",
		  "    reverse(top_order.begin(), top_order.end());",
		  "}"
		],
		"description": "top sort which necessiarly contans all nodes"
	  }
	  ,
	  "simplest imp of dijkstra": {
		"prefix": "dijkstra",
		"body": [
		  "ll int n, m;",
		  "vector<pair<ll int, ll int>> adj[100011];",
		  "vector<ll int> dist(100001 + 1, 1e18);",
		  "ll parent[100001];",
		  "void simple_dijkstra()",
		  "{",
		  "  priority_queue<pair<ll int, ll int>, vector<pair<ll int, ll int>>, greater<pair<ll int, ll int>>> q;",
		  "  q.push({0ll, 1ll});",
		  "  dist[1] = 0ll;",
		  "  while (!q.empty())",
		  "  {",
		  "    ll int currnode = q.top().second;",
		  "    ll int currdis = q.top().first;",
		  "    q.pop();",
		  "    if (dist[currnode] < currdis)",
		  "      continue;",
		  "    for (auto it : adj[currnode])",
		  "    {",
		  "      if (currdis + it.second < dist[it.first])",
		  "      {",
		  "        dist[it.first] = currdis + it.second;",
		  "        q.push({dist[it.first], it.first});",
		  "        parent[it.first]=currnode;",
		  "      }",
		  "    }",
		  "  }",
		  "}"
		],
		"description": "dijkstral algorithm"
	  }
}
