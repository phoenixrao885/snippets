{
	"named": {
		"prefix": "temp",
		"body": [
			"using namespace std;",
			"#include <bits/stdc++.h>",
			"#define ll long long",
			"#define ld long double",
			"#define EL '\\n'",
			"#define el '\\n'",
			"#define all(x) x.begin(),x.end()",
			"#define rep(i, a, b) for (ll i = (a); i < (b); i++)",
			"#define repd(i, a, b) for (ll i = (b)-1; i >= (a); i--)",
			"#define large 1000000007",
			"#define MOD 1000000007",
			"#define pb push_back",
			"#define MAX 10e+7",
			"#define FASTIO ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);",
			"void solve()",
			"{",
			"$1",
			"",
			"}",
			"int main()",
			"{",
			"     #ifndef ONLINE_JUDGE",
			"    freopen(\"input.txt\", \"r\", stdin);",
			"    freopen(\"output.txt\", \"w\", stdout);",
			"#endif",
			"FASTIO",
			" long long int t;",
			" cin>>t;",
			" while(t--)",
			" {",
			"  solve();",
			"  ",
			" }",
			"  return 0;",
			"}",
			""
		],
		"description": "named"
	},
	"rohit": {
		"prefix": "solutionsininiterval",
		"body": [
			"int gcd(int a, int b, int& x, int& y) {",
			"    if (b == 0) {",
			"        x = 1;",
			"        y = 0;",
			"        return a;",
			"    }",
			"    int x1, y1;",
			"    int d = gcd(b, a % b, x1, y1);",
			"    x = y1;",
			"    y = x1 - y1 * (a / b);",
			"    return d;",
			"}",
			"",
			"bool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {",
			"    g = gcd(abs(a), abs(b), x0, y0);",
			"    if (c % g) {",
			"        return false;",
			"    }",
			"",
			"    x0 *= c / g;",
			"    y0 *= c / g;",
			"    if (a < 0) x0 = -x0;",
			"    if (b < 0) y0 = -y0;",
			"    return true;",
			"}",
			"void shift_solution(int & x, int & y, int a, int b, int cnt) {",
			"    x += cnt * b;",
			"    y -= cnt * a;",
			"}",
			"",
			"int find_all_solutions(int a, int b, int c, int minx, int maxx, int miny, int maxy) {",
			"    int x, y, g;",
			"    if (!find_any_solution(a, b, c, x, y, g))",
			"        return 0;",
			"    a /= g;",
			"    b /= g;",
			"",
			"    int sign_a = a > 0 ? +1 : -1;",
			"    int sign_b = b > 0 ? +1 : -1;",
			"",
			"    shift_solution(x, y, a, b, (minx - x) / b);",
			"    if (x < minx)",
			"        shift_solution(x, y, a, b, sign_b);",
			"    if (x > maxx)",
			"        return 0;",
			"    int lx1 = x;",
			"",
			"    shift_solution(x, y, a, b, (maxx - x) / b);",
			"    if (x > maxx)",
			"        shift_solution(x, y, a, b, -sign_b);",
			"    int rx1 = x;",
			"",
			"    shift_solution(x, y, a, b, -(miny - y) / a);",
			"    if (y < miny)",
			"        shift_solution(x, y, a, b, -sign_a);",
			"    if (y > maxy)",
			"        return 0;",
			"    int lx2 = x;",
			"",
			"    shift_solution(x, y, a, b, -(maxy - y) / a);",
			"    if (y > maxy)",
			"        shift_solution(x, y, a, b, sign_a);",
			"    int rx2 = x;",
			"",
			"    if (lx2 > rx2)",
			"        swap(lx2, rx2);",
			"    int lx = max(lx1, lx2);",
			"    int rx = min(rx1, rx2);",
			"",
			"    if (lx > rx)",
			"        return 0;",
			"    return (rx - lx) / abs(b) + 1;",
			"}",
			""
		],
		"description": "all solution usinig euclid"
	},
	"primes": {
		"prefix": "seiveslow",
		"body": [
			"vector<char> is_prime(10001, true);",
			"void seive(int n)",
			"{",
			"//vector<char> is_prime(n+1, true);",
			"is_prime[0] = is_prime[1] = false;",
			"for (int i = 2; i <= n; i++) {",
			"    if (is_prime[i] && (long long)i * i <= n) {",
			"        for (int j = i * i; j <= n; j += i)",
			"            is_prime[j] = false;",
			"    }",
			"}",
			"}"
		],
		"description": "seive"
	},
	"ncr": {
		"prefix": "ncr%p",
		"body": [
			"#define MOD 1000000007",
			"const int N = 1000005;",
			"ll factorialNumInverse[N + 1]; ",
			"ll naturalNumInverse[N + 1]; ",
			"ll fact[N + 1]; ",
			"void InverseofNumber(ll p) ",
			"{ ",
			"    naturalNumInverse[0] = naturalNumInverse[1] = 1; ",
			"    for (int i = 2; i <= N; i++) ",
			"        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - p / i) % p; ",
			"} ",
			"void InverseofFactorial(ll p) ",
			"{ ",
			"     factorialNumInverse[0] = factorialNumInverse[1] = 1; ",
			"    for (int i = 2; i <= N; i++) ",
			"        factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p; ",
			"} ",
			"void factorial(ll p) ",
			"{ ",
			"    fact[0] = 1;  ",
			"    for (int i = 1; i <= N; i++) { ",
			"        fact[i] = (fact[i - 1] * i) % p; ",
			"    } ",
			"} ",
			"ll Binomial(ll N, ll R, ll p=MOD) ",
			"{ ",
			"  if(N<0||R<0||R>N) return 0;             ",
			"    ll ans = ((fact[N] * factorialNumInverse[R]) ",
			"              % p * factorialNumInverse[N - R]) ",
			"             % p; ",
			"    return ans%p; ",
			"}   ",
			"ll power(ll x, ll y, ll p) ",
			"{ ",
			"    int res = 1;",
			"    x = x % p;",
			"    while (y > 0) ",
			"    {  ",
			"        if (y & 1) ",
			"            res = (res*x) % p;  ",
			"        y = y>>1; // y = y/2 ",
			"        x = (x*x) % p; ",
			"    } ",
			"    return res; ",
			"} "
		],
		"description": "ncr%p"
	},
	"fenwicktree": {
		"prefix": "fenwicktree",
		"body": [
			"class BIT",
			"{",
			"int *ft, size;",
			"",
			"public:",
			"BIT(int n)",
			"{",
			"size = n;",
			"ft = new int[n + 1];",
			"fill_n(ft,n+1,0);",
			"}",
			"~BIT()",
			"{",
			"delete[] ft;",
			"}",
			"int sum(int b)",
			"{",
			"int sum = 0;",
			"for (; b; b -= b & (-b))",
			"sum += ft[b];",
			"return sum;",
			"}",
			"void update(int k, int v)",
			"{",
			"for (; k <= size; k += k & (-k))",
			"ft[k] += v;",
			"}",
			"int sumr(int a, int b)",
			"{",
			"return sum(b) - (a == 1 ? 0 : sum(a - 1));",
			"}",
			"int getValue(int x)",
			"{",
			"return sum(x) - sum(x - 1);",
			"}",
			"void changeElem(int x, int val)",
			"{",
			"update(x , val - getValue(x));",
			"}",
			"void scaleDown(int c)",
			"{",
			"for (int i = 1; i <= size; i++)",
			"ft[i] /= c;",
			"}",
			"void scaleUp(int c)",
			"{",
			"for (int i = 1; i <= size; i++)",
			"ft[i] *= c;",
			"}",
			"};",
			""
		],
		"description": "fenwick tree"
	},
	"temp1": {
		"prefix": "emp1",
		"body": [
			"using namespace std;",
			"#include <bits/stdc++.h>",
			"void solve()",
			"{",
			"$1",
			"",
			"}",
			"int main()",
			"{",
			"     #ifndef ONLINE_JUDGE",
			"    freopen(\"input.txt\", \"r\", stdin);",
			"    freopen(\"output.txt\", \"w\", stdout);",
			"#endif",
			"  int t=1;",
			" cin>>t;",
			" while(t--)",
			"  solve();",
			"  return 0;",
			"}",
			""
		],
		"description": "named"
	},
	"solutionofequation": {
		"prefix": "solutionofequation",
		"body": [
			"int gcd(int a, int b, int& x, int& y) {",
			"    if (b == 0) {",
			"        x = 1;",
			"        y = 0;",
			"        return a;",
			"    }",
			"    int x1, y1;",
			"    int d = gcd(b, a % b, x1, y1);",
			"    x = y1;",
			"    y = x1 - y1 * (a / b);",
			"    return d;",
			"}",
			"",
			"bool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {",
			"    g = gcd(abs(a), abs(b), x0, y0);",
			"    if (c % g) {",
			"        return false;",
			"    }",
			"",
			"    x0 *= c / g;",
			"    y0 *= c / g;",
			"    if (a < 0) x0 = -x0;",
			"    if (b < 0) y0 = -y0;",
			"    return true;",
			"}"
		],
		"description": "2 variable solution"
	},
	"power": {
		"prefix": "exponent",
		"body": [
			"#define MOD 1000000007",
			"ll power(ll x, ll y, ll p) ",
			"{ ",
			"    int res = 1;",
			"    x = x % p;",
			"    while (y > 0) ",
			"    {  ",
			"        if (y & 1) ",
			"            res = (res*x) % p;  ",
			"        y = y>>1; // y = y/2 ",
			"        x = (x*x) % p; ",
			"    } ",
			"    return res; ",
			"} "
		],
		"description": "a power b"
	},
	"long": {
		"prefix": "lamba",
		"body": [
			"#define ll long long"
		],
		"description": "long long"
	},
	"segment tree": {
		"prefix": "segmenttree",
		"body": [
			"struct item",
			"{",
			"    int a, c;",
			"};",
			"struct segtree",
			"{",
			"    int size;",
			"    int ele;",
			"    item single(int v)",
			"    {",
			"        return {v,1};",
			"    }",
			"    item NEUTRAL_ELEMENT={INT_MAX,0};",
			"    vector<item> values;",
			"    void init(int n)",
			"    {",
			"        ele = n;",
			"        size = 4 * n + 1;",
			"        values.resize(size);",
			"    }",
			"    item merge(item x,item y)",
			"    {",
			"       if(x.a<y.a) return x;",
			"       else if(x.a>y.a) return y;",
			"       else return {x.a,x.c+y.c};",
			"    }",
			"    void build(int *arr)",
			"    {",
			"        build(arr,1,0,ele-1);",
			"    }",
			"    void build(int *arr, int index, int s, int e)",
			"    {",
			"        if (s > e)",
			"            return;",
			"        if (s == e)",
			"        {",
			"            values[index]=single(arr[s]);",
			"            return;",
			"        }",
			"        int mid = (s + e) / 2;",
			"        build( arr, 2 * index, s, mid);",
			"        build( arr, 2 * index + 1, mid + 1, e);",
			"        values[index] = merge(values[2*index],values[2*index+1]);",
			"    }",
			"    void update(int i, int val)",
			"    {",
			"        update(0, ele - 1, 1, val, i);",
			"    }",
			"    void update(int s, int e, int index, int val, int i)",
			"    {",
			"        if (i < s || i > e)",
			"            return;",
			"        else if (s == e)",
			"        {",
			"            values[index] = single(val);",
			"            return;",
			"        }",
			"        int mid = (s + e) / 2;",
			"        update(s, mid, 2 * index, val, i);",
			"        update(mid + 1, e, 2 * index + 1, val, i);",
			"        values[index] = merge(values[2 * index] , values[2 * index + 1]);",
			"    }",
			"    item query(int qs, int qe)",
			"    {",
			"        return query(0, ele - 1, qs, qe, 1);",
			"    }",
			"    item query(int s, int e, int qs, int qe, int index)",
			"    {",
			"        if (qs > e || qe < s)",
			"            return NEUTRAL_ELEMENT;",
			"        if (s >= qs && e <= qe)",
			"            return values[index];",
			"        int mid = (s + e) / 2;",
			"        item lans = query(s, mid, qs, qe, 2 * index);",
			"        item rans = query(mid + 1, e, qs, qe, 2 * index + 1);",
			"        return  merge(lans, rans);",
			"    }",
			"};"
		],
		"description": "segment tree in genral form"
	},
	"equal ot greater index": {
		"prefix": "greaterthanindex",
		"body": [
			"int bsh(int val, int ar[], int n) {",
			"//return ind such that val >= ar[ind] and val < ar[ind+1] ",
			"int a = 0, b = n - 1, c = (a+b)/2;",
			"if (val < ar[0]) return -1;",
			"if (val >= ar[b]) return b;",
			" ",
			"while (!(val >= ar[c] && val < ar[c+1])) {",
			"if (val < ar[c]) b = c;",
			"else {",
			"if (b-a == 1 && c == a) a = b;",
			"else a = c;",
			"}",
			"c = (a+b)/2;",
			"}",
			"return c;",
			"}"
		],
		"description": "not in this one"
	},
	"largest power of 2 less than or equal to given number": {
		"prefix": "poweroftwolessthanorequal",
		"body": [
			"long long largest_power_of_two_less_than_or_equal(long long N)",
			"{",
			"    N = N | (N >> 1);",
			"    N = N | (N >> 2);",
			"    N = N | (N >> 4);",
			"    N = N | (N >> 8);",
			"    N = N | (N >> 16);",
			"    N = N | (N >> 32);",
			"    return (N + 1) >> 1;",
			"}"
		],
		"description": "."
	},
	"input output in side": {
		"prefix": "inputoutput",
		"body": [
			"  #ifndef ONLINE_JUDGE",
			"    freopen(\"input.txt\", \"r\", stdin);",
			"    freopen(\"output.txt\", \"w\", stdout);",
			"#endif"
		],
		"description": "for fast check"
	},
	"debugerichto": {
		"prefix": "debug",
		"body": [
			"// from radewoooooooshhhhh",
			"#define sim template < class c",
			"#define ris return * this",
			"#define dor > debug & operator <<",
			"#define eni(x) sim > typename \\",
			"enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {",
			"sim > struct rge { c b, e; };",
			"sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }",
			"sim > auto dud(c* x) -> decltype(cerr << *x, 0);",
			"sim > char dud(...);",
			"struct debug {",
			"~debug() { cerr << endl; }",
			"eni(!=) cerr << boolalpha << i; ris; }",
			"eni(==) ris << range(begin(i), end(i)); }",
			"sim, class b dor(pair < b, c > d) {",
			"  ris << \"(\" << d.first << \", \" << d.second << \")\";",
			"}",
			"sim dor(rge<c> d) {",
			"  *this << \"[\";",
			"  for (auto it = d.b; it != d.e; ++it)",
			"*this << \", \" + 2 * (it == d.b) << *it;",
			"  ris << \"]\";",
			"}",
			"};",
			"#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \""
		],
		"description": "warsaw template "
	},
	"lca of given nodes": {
		"prefix": "lca",
		"body": [
			"vector<int> adj[100001];",
			"bool visited[100001];",
			"int dis[100001];",
			"int par[100001];",
			"int table[100001][20];",
			"int maxn=log2(100001);",
			"int n,q;",
			"void dfs(int v,int p=-1)",
			"{",
			"  visited[v]=1;",
			"  if(p==-1)",
			"  dis[v]=0;",
			"  else",
			"  dis[v]=dis[p]+1;",
			"  par[v]=p;",
			"  table[v][0]=p;",
			"  for(auto it:adj[v])",
			"  {",
			"    if(!visited[it])",
			"    dfs(it,v);",
			"  }",
			"}",
			"void init()",
			"{",
			"  dfs(1);",
			"  for (int i = 1; i <=maxn; i++)",
			"  {",
			"    for (int j = 1; j <=n; j++)",
			"    {",
			"      if(table[j][i-1]!=-1)",
			"      {",
			"        int par=table[j][i-1];",
			"        table[j][i]=table[par][i-1];",
			"      }",
			"    }",
			"  }",
			"}",
			"int lca_fast(int a,int b)",
			"{",
			"  if(dis[b]<dis[a])",
			"  swap(a,b);",
			"  int d=dis[b]-dis[a];",
			"  while(d>0)",
			"  {",
			"    int base=log2(d);",
			"    b=table[b][base];",
			"    d-=(1<<base);",
			"  }",
			"  if(a==b)",
			"  return a;",
			"  for(int i=maxn;i>=0;i--)",
			"  {",
			"     if(table[a][i]!=-1&&table[b][i]!=-1&&table[a][i]!=table[b][i])",
			"     a=table[a][i],b=table[b][i];",
			"  }",
			"  return par[a];",
			"}",
			"int goup(int b,int d)",
			"{",
			"while(d>0)",
			"{",
			"int base=log2(d);",
			"b=table[b][base];",
			"if(b==-1)",
			"return -1;",
			"d-=(1<<base);",
			"}",
			"return b;",
			"}",
		],
		"description": "finds lca in log(n) time"
	},
	"khan algo": {
		"prefix": "topsortkhan",
		"body": [
			"vector<int> top_order; ",
			"bool topologicalsort() ",
			"{ ",
			"vector<int> in_degree(n+1, 0); ",
			"for (int u = 1; u <=n; u++) { ",
			"for (auto itr = adj[u].begin(); ",
			"itr != adj[u].end(); itr++) ",
			"in_degree[*itr]++; ",
			"} ",
			"queue<int> q; ",
			"for (int i = 1; i <=n; i++) ",
			"if (in_degree[i] == 0) ",
			"q.push(i); ",
			"int cnt = 0; ",
			"while (!q.empty()) { ",
			"int u = q.front(); ",
			"q.pop(); ",
			"top_order.push_back(u); ",
			"for (auto itr = adj[u].begin(); ",
			"itr != adj[u].end(); itr++) ",
			"if (--in_degree[*itr] == 0) ",
			"q.push(*itr); ",
			"",
			"cnt++; ",
			"}",
			"  if(cnt!=n)",
			"  return false;",
			"  return true;",
			"} "
		],
		"description": "for khan algo for top sort"
	},
	"articulation points": {
		"prefix": "articulationpoints",
		"body": [
			"void dfs(int v, int p = -1) {",
			"    visited[v] = true;",
			"    in[v] = low[v] = timer++;",
			"    int children=0;",
			"    for (int to : adj[v]) {",
			"        if (to == p) continue;",
			"        if (visited[to]) {",
			"            low[v] = min(low[v], in[to]);",
			"        } else {",
			"            dfs(to, v);",
			"            low[v] = min(low[v], low[to]);",
			"            if (low[to] >= in[v] && p!=-1)",
			"                IS_CUTPOINT(v);",
			"            ++children;",
			"        }",
			"    }",
			"    if(p == -1 && children > 1)",
			"",
			"        IS_CUTPOINT(v);",
			"}"
		],
		"description": "cut points"
	},
	"bridges": {
		"prefix": "bridges",
		"body": [
			"void dfs(int v, int p = -1) {",
			"    visited[v] = true;",
			"    in[v] = low[v] = timer++;",
			"    for (int to : adj[v]) {",
			"        if (to == p) continue;",
			"        if (visited[to]) {",
			"            low[v] = min(low[v], in[to]);",
			"        } else {",
			"            dfs(to, v);",
			"            low[v] = min(low[v], low[to]);",
			"            if (low[to] > in[v])",
			"                IS_BRIDGE(v, to);",
			"        }",
			"    }",
			"}"
		],
		"description": "find all bridges"
	},
	"top sort with check of cycle": {
		"prefix": "topsortall",
		"body": [
			"int n, m;",
			"vector<int> adj[1000001];",
			"vector<int> visited(100011);",
			"vector<int> top_order;",
			"bool possible;",
			"void dfs(int v)",
			"{",
			"  visited[v] = 1;",
			"  for (int u : adj[v])",
			"  {",
			"    if (!visited[u])",
			"      dfs(u);",
			"    else if (visited[u] == 1)",
			"      possible = 1;",
			"  }",
			"  visited[v] = 2;",
			"  top_order.push_back(v);",
			"}",
			"bool topological_sort()",
			"{",
			"  visited.assign(n + 1, 0);",
			"  top_order.clear();",
			"  for (int i = 1; i <= n; ++i)",
			"  {",
			"    if (visited[i] == 0)",
			"      dfs(i);",
			"  }",
			"  reverse(top_order.begin(), top_order.end());",
			"  if (possible == 1)",
			"    return false;",
			"  return true;",
			"}"
		],
		"description": "tested +ve"
	},
	"dij": {
		"prefix": "dijkstra",
		"body": [
		  "int n, m;",
		  "vector<pair<int, int>> adj[100011];",
		  "vector<int> dist(100001 + 1, 1e18);",
		  "int parent[100001];",
		  "void simple_dijkstra()",
		  "{",
		  "    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;",
		  "    q.push({0ll, 1});",
		  "    dist[1] = 0ll;",
		  "    while (!q.empty())",
		  "    {",
		  "         int currnode = q.top().second;",
		  "         int currdis = q.top().first;",
		  "        q.pop();",
		  "        if (dist[currnode] < currdis)",
		  "            continue;",
		  "        for (auto it : adj[currnode])",
		  "        {",
		  "            if (currdis + it.second < dist[it.first])",
		  "            {",
		  "                dist[it.first] = currdis + it.second;",
		  "                q.push({dist[it.first], it.first});",
		  "                parent[it.first] = currnode;",
		  "            }",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "define int long long"
	  },
	"fastio": {
		"prefix": "fastio",
		"body": [
			"   ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"    cout.tie(NULL);"
		],
		"description": "io fast"
	},
	"basic point in 3d": {
		"prefix": "point3d",
		"body": [
			"class point",
			"{",
			"public:",
			"    long long x, y, z;",
			"    point(long long emp1 = 0, long long emp2 = 0, long long emp3 = 0)",
			"    {",
			"        x = emp1;",
			"        y = emp2;",
			"        z = emp3;",
			"    }",
			"    point operator+(point b)",
			"    {",
			"        return point(this->x + b.x, this->y + b.y, this->z + b.z);",
			"    }",
			"    point operator-(point b)",
			"    {",
			"        return point(this->x - b.x, this->y - b.y, this->z - b.z);",
			"    }",
			"    point operator*(long long val)",
			"    {",
			"        return point(this->x * val, this->y * val, this->z * val);",
			"    }",
			"    point operator/(long long val)",
			"    {",
			"        return point(this->x / val, this->y / val, this->z / val);",
			"    }",
			"    point &operator=(point b)",
			"    {",
			"        this->x = b.x;",
			"        this->y = b.y;",
			"        this->z = b.z;",
			"        return *this;",
			"    }",
			"    point &operator+=(point b)",
			"    {",
			"        *this = *this + b;",
			"        return *this;",
			"    }",
			"    point &operator-=(point b)",
			"    {",
			"        *this = *this - b;",
			"        return *this;",
			"    }",
			"    point &operator*=(long long val)",
			"    {",
			"        (*this) = (*this) * val;",
			"        return *this;",
			"    }",
			"    point &operator/=(long long val)",
			"    {",
			"        (*this) = (*this) / val;",
			"        return *this;",
			"    }",
			"",
			"    bool operator==(const point &b) const",
			"    {",
			"        if (this->x == b.x && this->y == b.y && this->z == b.z)",
			"            return true;",
			"        else",
			"            return false;",
			"    }",
			"    bool operator<(const point &a) const",
			"    {",
			"        if (this->x == a.x)",
			"        {",
			"            return this->y < a.y;",
			"        }",
			"        return this->x < a.x;",
			"    }",
			"};"
		],
		"description": "genral point for 3d"
	},
	"basic operations": {
		"prefix": "pointoperations",
		"body": [
			"long long dot(point a, point b)",
			"{",
			"    return a.x * b.x + a.y * b.y + a.z * b.z;",
			"}",
			"point cross(point a, point b)",
			"{",
			"    return point(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);",
			"}",
			"double ang(point a, point b)",
			"{",
			"    return acos(dot(a, b) / sqrt(dot(a, a) * dot(b, b)));",
			"}",
			"double rad_to_deg(double val)",
			"{",
			"    return val * 180 / M_PI;",
			"}",
			"double deg_to_rad(double val)",
			"{",
			"    return val * M_PI / 180;",
			"}",
			"long long signed_area_of_parallelogram(point a, point b, point c)",
			"{",
			"    return cross(b - a, c - b).z;",
			"}",
			"double area_of_triangle(point a, point b, point c)",
			"{",
			"    return abs(signed_area_of_parallelogram(a, b, c) / 2.0);",
			"}",
			"int direction(point a, point b, point c)",
			"{",
			"    long long t = signed_area_of_parallelogram(a, b, c);",
			"",
			"    if (t < 0)",
			"        return -1;",
			"    else if (t > 0)",
			"        return 1;",
			"    else",
			"        return 0;",
			"}",
			"double distance_between_points(point a, point b)",
			"{",
			"    double val1 = (double)a.x - (double)b.x;",
			"    double val2 = (double)a.y - (double)b.y;",
			"    double val3 = (double)a.z - (double)b.z;",
			"    return sqrt(val1 * val1 + val2 * val2 + val3 * val3);",
			"}"
		],
		"description": "genral point operation"
	},
	"2d point tools": {
		"prefix": "point2dtools",
		"body": [
			"// for 2d bodies",
			"double area_of_polygon(point a[], int n)",
			"{",
			"    double area = 0;",
			"    for (int i = 0; i < n; i++)",
			"    {",
			"        area -= (a[(i + 1) % n].x - a[i].x) * (a[(i + 1) % n].y + a[i].y);",
			"        // i= n-1, a(0)->a(n-1)",
			"    }",
			"    area /= 2;",
			"    return abs(area);",
			"}",
			"bool check_point_in_polygon(point a[], int n, point p)",
			"{",
			"   // for convex polygons ",
			"    int l = 1, r = n - 2;",
			"    while (l < r)",
			"    {",
			"        int x = (l + r) / 2;",
			"",
			"        if (direction(a[0], a[x + 1], p) == 1)",
			"            l = x + 1;",
			"        else if (direction(a[0], a[x], p) == -1)",
			"            r = x - 1;",
			"        else",
			"            l = r = x;",
			"    }",
			"    if (area_of_triangle(a[0], a[l], a[l + 1]) == area_of_triangle(a[0], a[l], p) + area_of_triangle(a[l], a[l + 1], p) + area_of_triangle(a[l + 1], a[0], p))",
			"        return true;",
			"    return false;",
			"}"
		],
		"description": "area and check for a point in a polygon till now....."
	},
	"minkowski sum and redundant points ": {
		"prefix": "minkowskisum",
		"body": [
			"// minkowski sum it might contain redudant points not renoved in this fucntion",
			"vector<point> minkowski_sum(vector<point> a, vector<point> b)",
			"{",
			"    int n = a.size(), m = b.size();",
			"    // find the left most and bottom most point in both polygons as their index in l and r",
			"    int l = 0;",
			"    for (int i = 0; i < n; i++)",
			"    {",
			"        if (a[i].x < a[l].x || (a[i].x == a[l].x && a[i].y < a[l].y))",
			"        {",
			"            l = i;",
			"        }",
			"    }",
			"    int r = 0;",
			"    for (int i = 0; i < m; i++)",
			"    {",
			"        if (b[i].x < b[r].x || (b[i].x == b[r].x && b[i].y < b[r].y))",
			"        {",
			"            r = i;",
			"        }",
			"    }",
			"    vector<point> v;",
			"    for (int i = 0; i < n + m; i++)",
			"    {",
			"        v.push_back(a[l] + b[r]);",
			"        if (cross(a[(l + 1) % n] - a[l], b[(r + 1) % m] - b[r]).z >= 0)",
			"        {",
			"            // this is lower (or below r) than r so take it",
			"            l = (l + 1) % n;",
			"        }",
			"        else",
			"        {",
			"            r = (r + 1) % n;",
			"        }",
			"    }",
			"    return v;",
			"}",
			"// remove reduandant point in minkowski sum final vector",
			"vector<point> remove_redundant(vector<point> v, int n)",
			"{",
			"    vector<point> vv;",
			"    unordered_set<int> mark;",
			"    for (int i = 0; i < n; i++)",
			"        if (direction(v[i], v[(i + 1) % (n)], v[(i + 2) % (n)]) == 0)",
			"            mark.insert((i + 1) % (n));",
			"    for (int i = 0; i < n; i++)",
			"        if (!mark.count(i))",
			"            vv.push_back(v[i]);",
			"    return vv;",
			"}"
		],
		"description": "minkowaski sum"
	},
	"line in 2d": {
		"prefix": "line2d",
		"body": [
			"class line",
			"{",
			"public:",
			"  ll a, b, c;",
			"  line(ll x = 0, ll y = 0, ll z = 0)",
			"  {",
			"    a = x, b = y, c = z;",
			"  }",
			"  bool operator==(line x)",
			"  {",
			"    if (x.a == this->a && x.b == this->b && x.c == this->c)",
			"      return true;",
			"    return false;",
			"  }",
			"  bool operator!=(line x)",
			"  {",
			"    if (x.a == this->a && x.b == this->b && x.c == this->c)",
			"      return false;",
			"    return true;",
			"  }",
			"};",
			"double slope(line x)",
			"{",
			"  if (x.b == 0 && x.a == 0)",
			"    return 0.0;",
			"  assert(x.b != 0);",
			"  return -((double)x.a / (double)x.b);",
			"}",
			"double rad_to_deg(double val)",
			"{",
			"  return val * 180 / M_PI;",
			"}",
			"double deg_to_rad(double val)",
			"{",
			"  return val * M_PI / 180;",
			"}",
			"bool is_parallel(line x, line y)",
			"{",
			"  double val1 = (double)x.a / (double)y.a;",
			"  double val2 = (double)x.b / (double)y.b;",
			"  double val3 = (double)x.c / (double)y.c;",
			"  return (val1 == val2 && val2 != val3);",
			"}",
			"bool is_horizontal(line x)",
			"{",
			"  if (x.a == 0)",
			"    return true;",
			"  return false;",
			"}",
			"bool is_vertical(line x)",
			"{",
			"  if (x.b == 0)",
			"    return true;",
			"  return false;",
			"}",
			"bool do_intersect(line x, line y)",
			"{",
			"  if (x == y || is_parallel(x, y))",
			"    return false;",
			"  if (is_vertical(x) && is_vertical(y) && !(x == y))",
			"    return false;",
			"  if (is_horizontal(x) && is_horizontal(y) && !(x == y))",
			"    return false;",
			"  double val1 = (double)x.a / (double)y.a;",
			"  double val2 = (double)x.b / (double)y.b;",
			"  return val1 != val2;",
			"}",
			"pair<double, double> intersection_point(line x, line y)",
			"{",
			"  double val1 = (double)x.a * (double)y.b - (double)y.a * (double)x.b;",
			"  double val2 = (double)x.b * (double)y.c - (double)y.b * (double)x.c;",
			"  double val3 = (double)x.c * (double)y.a - (double)y.c * (double)x.a;",
			"  return make_pair(val2 / val1, val3 / val1);",
			"}",
			"double distance_point_to_line(line x, point a)",
			"{",
			"  double val1 = (double)x.a * (double)a.x + (double)x.b * (double)a.y + (double)x.c;",
			"  double val2 = sqrt((double)x.a * (double)x.a + (double)x.b * (double)x.b);",
			"  return (abs(val1)) / val2;",
			"}",
			"pair<double, double> image_in_line(line x, point a)",
			"{",
			"  double val1 = (double)x.a * (double)x.a + (double)x.b * (double)x.b;",
			"  double val2 = (double)-2.0 * ((double)x.a * (double)a.x + (double)x.b * (double)a.y + (double)x.c);",
			"  double val = val2 / val1;",
			"  double p1 = (double)a.x + (double)x.a * (val);",
			"  double p2 = (double)a.y + (double)x.b * (val);",
			"  return make_pair(p1, p2);",
			"}",
			"pair<double, double> foot_of_perpendicular(line x, point a)",
			"{",
			"  double val1 = (double)x.a * (double)x.a + (double)x.b * (double)x.b;",
			"  double val2 = -((double)x.a * (double)a.x + (double)x.b * (double)a.y + (double)x.c);",
			"  double val = val2 / val1;",
			"  double p1 = (double)a.x + (double)x.a * (val);",
			"  double p2 = (double)a.y + (double)x.b * (val);",
			"  return make_pair(p1, p2);",
			"}",
			"bool is_perperdicular(line a, line b)",
			"{",
			"  ll val1 = a.a * b.a;",
			"  ll val2 = a.b * b.b;",
			"  if (val1 == -1 * val2)",
			"    return true;",
			"  return false;",
			"}",
			"pair<double, double> angle_between_lines(line x, line y)",
			"{",
			"  // return angle in degree <small,large>",
			"  double val1 = slope(x);",
			"  double val2 = slope(y);",
			"  double aa = atan((val1 - val2) / (1.0 + val1 * val2));",
			"  double ab = atan(-1.0 * ((val1 - val2) / (1.0 + val1 * val2)));",
			"  aa += (acos(-1));",
			"  ab += (acos(-1));",
			"  double pi = acos(-1);",
			"  ///// % is not defined for double use floor technique here",
			"  pair<double,double> p1;",
			"  p1.first = min(aa, ab);",
			"  p1.second = max(aa, ab);",
			"  p1.first = rad_to_deg(p1.first);",
			"  p1.second = rad_to_deg(p1.second);",
			"  p1.first -= (((int)p1.first) / 180) * 180;",
			"  p1.second -= (((int)p1.second) / 180) * 180;",
			"  return make_pair(min(p1.first,p1.second),max(p1.first,p1.second));",
			"}",
			"bool on_line(line x, point a)",
			"{",
			"  if (x.a * a.x + x.b * a.y + x.c == 0)",
			"    return true;",
			"  return false;",
			"}",
			"int on_same_side(line x, point a, point b)",
			"{",
			"  ll val1 = x.a * a.x + x.b * a.y + x.c;",
			"  ll val2 = x.a * b.x + x.b * b.y + x.c;",
			"  if (val1 * val2 < 0)",
			"    return 1;",
			"  else if (val1 * val2 > 0)",
			"    return -1;",
			"  return 0;",
			"}",
			"// for a 2d line ",
			"line eqn_from2points(point a, point b)",
			"{",
			" ll val1 = b.y - a.y;",
			"ll val2 = b.x - a.x;",
			"line t;",
			"t.a = val1;",
			" t.b = -1 * val2;",
			"t.c = (val2 * a.y - val1 * a.x);",
			" return t;",
			"}"
		],
		"description": "line in 3d with basic stufs"
	},
	"circle in form (x-x0)^2+(y-y0)^2=r": {
		"prefix": "circle",
		"body": [
			"class circle",
			"{",
			"public:",
			"    double x, y, r;",
			"    circle(double emp1 = 0, double emp2 = 0, double emp3 = 0)",
			"    {",
			"        x = emp1, y = emp2, r = emp3;",
			"    }",
			"    bool operator==(circle a)",
			"    {",
			"        if (a.y == this->y && a.x == this->x && a.r == this->r)",
			"            return true;",
			"        return false;",
			"    }",
			"};",
			"int check_incircle(circle a, point b)",
			"{",
			"    double val1 = (double)(((double)b.x - a.x) * (double)((double)b.x - a.x)) + (double)(((double)b.y - a.y) * (double)((double)b.y - a.y)) - (a.r * a.r);",
			"    if (val1 == 0.0)",
			"        return 0;",
			"    if (val1 > 0)",
			"        return 1;",
			"    return -1;",
			"}",
			"",
			"bool is_tangent(circle a, line b)",
			"{",
			"    double val1 = distance_point_to_line(b, point(a.x, a.y));",
			"    if (val1 == a.r)",
			"        return true;",
			"    return false;",
			"}",
			"double length_of_tangent(circle a, point b)",
			"{",
			"    //sqrt(S1)",
			"    double val1 = (double)(((double)b.x - a.x) * (double)((double)b.x - a.x)) + (double)(((double)b.y - a.y) * (double)((double)b.y - a.y)) - (a.r * a.r);",
			"    return sqrt(val1);",
			"}",
			"int no_of_points_of_intersection(circle a, circle b)",
			"{",
			"    if (a == b)",
			"        return INT_MAX;",
			"    double val1 = a.r + b.r;",
			"    double val2 = distance_between_points(point(a.x, a.y), point(b.x, b.y));",
			"    if (val1 == val2)",
			"        return 1;",
			"    else if (val2 == (abs(a.r - b.r)))",
			"        return 1;",
			"    else if (val2 > val1)",
			"        return 0;",
			"    else if (val2 < val1 && val2 > (abs(a.r - b.r)))",
			"        return 2;",
			"    return 0;",
			"}",
			"double angle_btwn_circles(circle a, circle b)",
			"{",
			"    double val1 = a.r * a.r + b.r * b.r - ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));",
			"    double val2 = 2.0 * a.r * b.r;",
			"    double val3 = val1 / val2;",
			"    return rad_to_deg(acos(val3));",
			"}",
			"// radical axis // 2(g-g')x+2(f-f')y+c-c'=0;",
			"// not implemented due to precission errors with value of c here"
		],
		"description": "basic circle stuff"
	},
	"convex hull jarvis march": {
		"prefix": "jarvismarch",
		"body": [
			"vector<point> jarvis_march(vector<point> arr)",
			"{",
			"    // with no redundant points ",
			"// complexity =(no of points in hull)*(total no of points) ",
			"    int n = arr.size();",
			"    int start = 0;",
			"    for (int i = 1; i < n; i++)",
			"    {",
			"        if (arr[i].x < arr[start].x || (arr[i].x == arr[start].x && arr[i].y < arr[start].y))",
			"            start = i;",
			"    }",
			"    vector<point> ans;",
			"    ans.push_back(arr[start]);",
			"    while (1)",
			"    {",
			"        int pt = 0;",
			"        for (int i = 0; i < n; i++)",
			"        {",
			"            if (arr[i] == ans.back())",
			"                continue;",
			"            if ((direction(ans.back(), arr[pt], arr[i]) == -1) ||",
			"                (direction(ans.back(), arr[pt], arr[i]) == 0 &&",
			"                 dot(arr[i] - ans.back(), arr[i] - ans.back()) > dot(arr[pt] - ans.back(), arr[pt] - ans.back())))",
			"            {",
			"                pt = i;",
			"            }",
			"        }",
			"        if (arr[pt] == ans.front())",
			"            break;",
			"        else",
			"            ans.push_back(arr[pt]);",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "jarvis march without redundant points"
	},
	"disjoint set union": {
		"prefix": "dsu",
		"body": [
			"// you know from where it is copied ",
			"class dsu",
			"{",
			"public:",
			"  vector<int> p;",
			"  int n;",
			"  dsu(int _n) : n(_n)",
			"  {",
			"    p.resize(n);",
			"    iota(p.begin(), p.end(), 0);",
			"  }",
			"  inline int get(int x)",
			"  {",
			"    return (x == p[x] ? x : (p[x] = get(p[x])));",
			"  }",
			"  inline bool unite(int x, int y)",
			"  {",
			"    x = get(x);",
			"    y = get(y);",
			"    if (x != y)",
			"    {",
			"      p[x] = y;",
			"      return true;",
			"    }",
			"    return false;",
			"  }",
			"};",
		],
		"description": "dsu with path compression"
	},
	"pbds": {
		"prefix": "pbds",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>"
		],
		"description": "pbds"
	},
	"flood fill arrays": {
		"prefix": "floodfillarrays",
		"body": [
			"int aa[] = {-1, -2, -2, -1, 1, 2, 2, 1};",
			"int bb[] = {-2, -1, 1, 2, 2, 1, -1, -2};",
			"int a[]  ={1,0,-1,0};",
			"int b[]  ={0,1,0,-1};"
		],
		"description": "flood fill arrays"
	},
	"for time test file": {
		"prefix": "time",
		"body": [
		  "#ifndef ONLINE_JUDGE",
		  "    auto begin = std::chrono::high_resolution_clock::now();",
		  "    freopen(\"input.txt\", \"r\", stdin);",
		  "    freopen(\"output.txt\", \"w\", stdout);",
		  "#endif",
		  "    int t = 1;",
		  "    cin >> t;",
		  "    while (t--)",
		  "        solve();",
		  "#ifndef ONLINE_JUDGE",
		  "    auto end = std::chrono::high_resolution_clock::now();",
		  "    cout << setprecision(4) << fixed;",
		  "    cerr << \"Execution time: \" << std::chrono::duration_cast<std::chrono::duration<double>>(end - begin).count() << \" seconds\" << endl;",
		  "#endif"
		],
		"description": "print runtime"
	  }
	,
	"segment tree with lazy propagation": {
		"prefix": "segmenttreelazy",
		"body": [
		  "struct item",
		  "{",
		  "    int a;",
		  "    int operation;",
		  "    int mi;",
		  "    // if operation is for checking if the current node have operation or not",
		  "};",
		  "struct segtree",
		  "{",
		  "    int size;",
		  "    int ele;",
		  "    int NO_OPERATION = LONG_LONG_MAX;",
		  "    // ... well well well",
		  "    // ... do change the merge function while merging the answer of the nodes ",
		  "    // ... apply_operation for changing the values in the nodes for the propagation of the ndoes ",
		  "    // ... in to its childrens",
		  "    // ... change necessarty stufff",
		  "    // ... do not forgot to change the neutal element and merge function",
		  "    item single(int v)",
		  "    {",
		  "        return {v, NO_OPERATION, v};",
		  "    }",
		  "    item NEUTRAL_ELEMENT = {0, 0, LONG_LONG_MAX};",
		  "    vector<item> values;",
		  "    void init(int n)",
		  "    {",
		  "        ele = n;",
		  "        size = 4 * n + 1;",
		  "        values.resize(size);",
		  "    }",
		  "    item apply_operation(item a, item b, int s, int e)",
		  "    {",
		  "        // ... all the imp stuff for propagating from a node to its childrens come from here",
		  "        // ... see what we want to perform see if we need the length of this crrent segment",
		  "        // ... also how to modify operation and values after it",
		  "        if (b.operation == NO_OPERATION)",
		  "            return a;",
		  "        item c = a;",
		  "        if (c.operation == NO_OPERATION)",
		  "            c.operation = b.operation;",
		  "        else",
		  "            c.operation += b.operation;",
		  "        c.a += (e - s + 1) * b.operation;",
		  "        if (b.operation != NO_OPERATION)",
		  "            c.mi += (b.operation);",
		  "        return c;",
		  "    }",
		  "    void apply(item &a, item b, int s, int e)",
		  "    {",
		  "        // s and e for the node for which we want to push value into like the children of the current node",
		  "        // here a is the childeren node and b is the parent node",
		  "        a = apply_operation(a, b, s, e);",
		  "    }",
		  "    void propagate(int s, int e, int index)",
		  "    {",
		  "        if (s == e)",
		  "            return;",
		  "        apply(values[2 * index], values[index], s, (s + e) / 2);",
		  "        apply(values[2 * index + 1], values[index], ((s + e) / 2) + 1, e);",
		  "        values[index].operation = NO_OPERATION;",
		  "    }",
		  "    item merge(item x, item y)",
		  "    {",
		  "        return {x.a + y.a, NO_OPERATION, min(x.mi, y.mi)};",
		  "    }",
		  "    void build(int *arr)",
		  "    {",
		  "        build(arr, 1, 0, ele - 1);",
		  "    }",
		  "    void build(int *arr, int index, int s, int e)",
		  "    {",
		  "        if (s > e)",
		  "            return;",
		  "        if (s == e)",
		  "        {",
		  "            values[index] = single(arr[s]);",
		  "            return;",
		  "        }",
		  "        int mid = (s + e) / 2;",
		  "        build(arr, 2 * index, s, mid);",
		  "        build(arr, 2 * index + 1, mid + 1, e);",
		  "        values[index] = merge(values[2 * index], values[2 * index + 1]);",
		  "    }",
		  "    void update(int i, int val)",
		  "    {",
		  "        update(0, ele - 1, 1, val, i);",
		  "    }",
		  "    void update(int s, int e, int index, int val, int i)",
		  "    {",
		  "        if (i < s || i > e)",
		  "            return;",
		  "        else if (s == e)",
		  "        {",
		  "            values[index] = single(val);",
		  "            return;",
		  "        }",
		  "        int mid = (s + e) / 2;",
		  "        update(s, mid, 2 * index, val, i);",
		  "        update(mid + 1, e, 2 * index + 1, val, i);",
		  "        values[index] = merge(values[2 * index], values[2 * index + 1]);",
		  "    }",
		  "    void update_range(int qs, int qe, int val)",
		  "    {",
		  "        update_range(0, ele - 1, qs, qe, 1, val);",
		  "    }",
		  "    void update_range(int s, int e, int qs, int qe, int index, int val)",
		  "    {",
		  "        propagate(s, e, index);",
		  "        if (qs > e || qe < s)",
		  "            return;",
		  "        else if (s >= qs && e <= qe)",
		  "        {",
		  "            values[index].a += (e - s + 1) * val;",
		  "            values[index].mi += val;",
		  "            if (values[index].operation == NO_OPERATION)",
		  "                values[index].operation = val;",
		  "            else",
		  "                values[index].operation += val;",
		  "            assert(values[index].operation <= NO_OPERATION);",
		  "            return;",
		  "        }",
		  "        int mid = (s + e) / 2;",
		  "        update_range(s, mid, qs, qe, 2 * index, val);",
		  "        update_range(mid + 1, e, qs, qe, 2 * index + 1, val);",
		  "        values[index] = merge(values[2 * index], values[2 * index + 1]);",
		  "    }",
		  "    item query(int qs, int qe)",
		  "    {",
		  "        return query(0, ele - 1, qs, qe, 1);",
		  "    }",
		  "    item query(int s, int e, int qs, int qe, int index)",
		  "    {",
		  "        propagate(s, e, index);",
		  "        if (qs > e || qe < s)",
		  "            return NEUTRAL_ELEMENT;",
		  "        else if (s >= qs && e <= qe)",
		  "        {",
		  "            return values[index];",
		  "        }",
		  "        int mid = (s + e) / 2;",
		  "        item lans = query(s, mid, qs, qe, 2 * index);",
		  "        item rans = query(mid + 1, e, qs, qe, 2 * index + 1);",
		  "        return merge(lans, rans);",
		  "    }",
		  "};"
		],
		"description": "lazy propagation"
	  }
	  ,
	  "sieve in o(n)": {
		"prefix": "seivefast",
		"body": [
		  "// https://codeforces.com/profile/neal ",
		  "vector<int> smallest_factor;",
		  "vector<bool> prime;",
		  "vector<int> primes;",
		  "void sieve(int maximum) {",
		  "    maximum = max(maximum, 1);",
		  "    smallest_factor.assign(maximum + 1, 0);",
		  "    prime.assign(maximum + 1, true);",
		  "    prime[0] = prime[1] = false;",
		  "    primes = {};",
		  "    for (int p = 2; p <= maximum; p++)",
		  "        if (prime[p]) {",
		  "            smallest_factor[p] = p;",
		  "            primes.push_back(p);",
		  "            for (int64_t i = int64_t(p) * p; i <= maximum; i += p)",
		  "                if (prime[i]) {",
		  "                    prime[i] = false;",
		  "                    smallest_factor[i] = p;",
		  "                }",
		  "        }",
		  "}"
		],
		"description": "sieve with all sttuf i know"
	  }
	  ,
	  "integer factorization": {
		"prefix": "factorige",
		"body": [
		  "//https://codeforces.com/profile/neal",
		  "// Prime factorizes n in worst case O(sqrt n / log n). Requires having run `sieve` up to at least sqrt(n).",
		  "// If we've run `sieve` up to at least n, takes O(log n) time.",
		  "vector<pair<int64_t, int>> prime_factorize(int64_t n) {",
		  "    int64_t sieve_max = int64_t(smallest_factor.size()) - 1;",
		  "    assert(1 <= n && n <= sieve_max * sieve_max);",
		  "    vector<pair<int64_t, int>> result;",
		  " ",
		  "    if (n <= sieve_max) {",
		  "        while (n != 1) {",
		  "            int64_t p = smallest_factor[n];",
		  "            int exponent = 0;",
		  " ",
		  "            do {",
		  "                n /= p;",
		  "                exponent++;",
		  "            } while (n % p == 0);",
		  " ",
		  "            result.emplace_back(p, exponent);",
		  "        }",
		  " ",
		  "        return result;",
		  "    }",
		  " ",
		  "    for (int64_t p : primes) {",
		  "        if (p * p > n)",
		  "            break;",
		  " ",
		  "        if (n % p == 0) {",
		  "            result.emplace_back(p, 0);",
		  " ",
		  "            do {",
		  "                n /= p;",
		  "                result.back().second++;",
		  "            } while (n % p == 0);",
		  "        }",
		  "    }",
		  " ",
		  "    if (n > 1)",
		  "        result.emplace_back(n, 1);",
		  " ",
		  "    return result;",
		  "}",
		  " ",
		  "vector<int64_t> generate_factors(const vector<pair<int64_t, int>> &prime_factors, bool sorted = false) {",
		  "    // See http://oeis.org/A066150 and http://oeis.org/A036451 for upper bounds on number of factors.",
		  "    static vector<int64_t> buffer;",
		  "    int product = 1;",
		  " ",
		  "    for (auto &pf : prime_factors)",
		  "        product *= pf.second + 1;",
		  " ",
		  "    vector<int64_t> factors = {1};",
		  "    factors.reserve(product);",
		  " ",
		  "    if (sorted)",
		  "        buffer.resize(product);",
		  " ",
		  "    for (auto &pf : prime_factors) {",
		  "        int64_t p = pf.first;",
		  "        int exponent = pf.second;",
		  "        int before_size = int(factors.size());",
		  " ",
		  "        for (int i = 0; i < exponent * before_size; i++)",
		  "            factors.push_back(factors[factors.size() - before_size] * p);",
		  " ",
		  "        if (sorted && factors[before_size - 1] > p)",
		  "            for (int section = before_size; section < int(factors.size()); section *= 2)",
		  "                for (int i = 0; i + section < int(factors.size()); i += 2 * section) {",
		  "                    int length = min(2 * section, int(factors.size()) - i);",
		  "                    merge(factors.begin() + i, factors.begin() + i + section,",
		  "                          factors.begin() + i + section, factors.begin() + i + length,",
		  "                          buffer.begin());",
		  "                    copy(buffer.begin(), buffer.begin() + length, factors.begin() + i);",
		  "                }",
		  "    }",
		  " ",
		  "    assert(int(factors.size()) == product);",
		  "    return factors;",
		  "}",
		  " "
		],
		"description": "foctorize and genrte all the factors"
	  }
	  ,
	  "new ncr": {
		"prefix": "ncr",
		"body": [
		  "#define ll long long",
		  "const int N = 2e6 + 10, mod = 1e9 + 7;",
		  "int fact[N], invfact[N], p2[N], invp2[N];",
		  "inline int add(int x, int y){ x += y; if(x >= mod) x -= mod; return x;}",
		  "inline int sub(int x, int y){ x -= y; if(x < 0) x += mod; return x;}",
		  "inline int mul(int x, int y){ return (((ll) x) * y) % mod;}",
		  "inline int powr(int a, ll b){",
		  "int x = 1 % mod;",
		  "while(b){",
		  "if(b & 1) x = mul(x, a);",
		  "a = mul(a, a);",
		  "b >>= 1;",
		  "}",
		  "return x;",
		  "}",
		  "inline int inv(int a){ return powr(a, mod - 2);}",
		  "void pre(){",
		  "fact[0] = invfact[0] = p2[0] = invp2[0] = 1;",
		  "for(int i = 1;i < N; i++){",
		  "fact[i] = mul(i, fact[i - 1]);",
		  "p2[i] = mul(2, p2[i - 1]);",
		  "invp2[i] = mul(invp2[i - 1], (mod + 1) >> 1);",
		  "}",
		  "invfact[N - 1] = inv(fact[N - 1]);",
		  "for(int i = N - 2; i >= 1; i--) invfact[i] = mul(invfact[i + 1], i + 1);",
		  "assert(invfact[1] == 1);",
		  "}",
		  " ",
		  "inline int C(int n, int k){",
		  "if(n < k || k < 0) return 0;",
		  "return mul(fact[n], mul(invfact[k], invfact[n - k]));",
		  "}"
		],
		"description": "mod"
	  }
	
}
